<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <style>

        head, body
        {
            width:100%;
            height:100%;
            overflow: hidden;
            margin:0;
            padding:0;
            /*background-color: #EEE;*/
        }

    </style>
</head>
<body>


<script src="../base.js"></script>
<script src="../geom.js"></script>
<script src="../graphics.js"></script>
<script src="loader.js"></script>
<script src="utils/cardinal.js"></script>
<script src="utils/catmullrom.js"></script>
<script src="utils/simplify.js"></script>
<script src="utils/quadratic.js"></script>
<script src="utils/kmeans.js"></script>

<canvas id="ctx0"></canvas>
<canvas id="ctx1"></canvas>
<canvas id="ctx2"></canvas>
<canvas id="ctx3"></canvas>
<canvas id="ctx4"></canvas>

<script>

    /*
    le CSV provient de:
     https://donneespubliques.meteofrance.fr/?fond=produit&id_produit=90&id_rubrique=32
     c'est un relevé météo sur 51 stations en france métropolitaine

     le détail du format se trouve dans le pdf doc_parametres_synop_168.pdf
     */

    //on charge le CSV une fois qu ela page est chargée
    window.onload = function()
    {
        document.body.removeChild( canvas );

        ctx0 = document.getElementById("ctx0").getContext( "2d" );
        ctx1 = document.getElementById("ctx1").getContext( "2d" );
        ctx2 = document.getElementById("ctx2").getContext( "2d" );
        ctx3 = document.getElementById("ctx3").getContext( "2d" );
        ctx4 = document.getElementById("ctx4").getContext( "2d" );
        ctxs = [ ctx0, ctx1, ctx2, ctx3, ctx4 ];

        loader.load( "synop.2015102115.csv", onCSVReady );
    };

    //on branche l'utilitaire de dessin sur le contexte
    var G = new Graphics( ctx );

    //on stockera nos données dans data
    var data = [];

    var ctx0, ctx1, ctx2, ctx3, ctxs;


    //bornes des valeurs de température
    var t_min,t_max;
    //bornes des valeurs de vitesse du vent
    var ff_min,ff_max;

    /**
     * méthode qui renvoie les bornes d'une clé sur un objet data
     * @param data le set de données
     * @param key la clé dont on veut récupérer les minimums/maximum
     * @returns {*[]} un tableau contenant les bornes minimums/maximum de la clé
     */
    function getBounds( data, key )
    {
        var min = Math.pow( 2, 53 );
        var max = -Math.pow( 2, 53 );

        data.forEach(function(obj) {

            min = Math.min( min, obj[key] );
            max = Math.max( max, obj[key] );

        });
        return [min, max];
    }

    function onCSVReady( result )
    {

        data = result;

        var bounds = getBounds( data, 't' );
        t_min = bounds[0];
        t_max = bounds[1];

        bounds = getBounds( data, 'ff' );
        ff_min = bounds[0];
        ff_max = bounds[1];

        console.log( 'temperatures: t_min', t_min, 't_max', t_max );
        console.log( 'vent: ff_min', ff_min, 'ff_max', ff_max );


        draw();

    }

    function graduation( p0, p1, count, width )
    {
        G.line( p0, p1 );
        var p = new Point();
        var n = new Point( -( p1.y - p0.y ),  ( p1.x - p0.x ) );
        n.normalize( width || 5 );

        for( var i = 0; i <= count; i++ )
        {
            var t = i/count;
            p.x = lerp( t, p0.x, p1.x );
            p.y = lerp( t, p0.y, p1.y );
            G.line( p, Point.add( p,n ) );
        }

    }

    function getPositionAt( points, t )
    {

        var length = points.length-1;
        var i0 = Math.floor( length * t );
        i0 = i0 < length - 1 ? i0 : length - 1;
        var i1 = Math.min( i0 + 1, length );

        var delta = 1 / length;
        var nt =  ( t - ( i0 * delta ) ) / delta;

        return p = new Point(
            lerp( nt, points[i0].x, points[i1].x ),
            lerp( nt, points[i0].y, points[i1].y )
        );
    }

    function draw()
    {
        requestAnimationFrame(draw);


        var width = 400;
        var height = 300;

        var p0 = new Point(0,0);
        var p1 = new Point(0,height);
        var p2 = new Point(width, height );

        ctxs.forEach(function(ctx){

            ctx.restore();
            ctx.save();
            ctx.clearRect(0,0,w,h);
            ctx.canvas.width = width + 15;
            ctx.canvas.height = height + 5;

            ctx.strokeStyle = "#DDD";
            ctx.translate( 5, 1 );

            G.ctx = ctx;
            graduation( p0, p1, 10, 5 );
            graduation( p1, p2, data.length, 5 );

        });


        //on va mapper les valeurs des points entre leurs bornes et le rectangle
        var temperatures = [];
        var winds = [];
        var x, y;
        var marginX = 0;
        var marginY = 50;

        data.forEach( function( obj, i )
        {

            //espacement régulier en X
            x = map( i, 0, data.length, marginX, width - marginX );

            //mappe la valeur T de l'objet en cours entre t_min / t_max
            y = map( obj.t, t_min, t_max, height - marginY, marginY );
            temperatures.push( new Point( x, y ) );

            //mappe la valeur FF de l'objet en cours entre ff_min / f_max
            y = map( obj.ff, ff_min, ff_max, height - marginY, marginY );
            winds.push( new Point( x, y ) );

        });


        //trace le graphe des températures en bleu
        ctx0.fillStyle = ctx0.strokeStyle = "#09C";
        G.ctx = ctx0;
        G.polyline( temperatures );
//        temperatures.forEach(function( p ){ G.disc(p.x, p.y,2 );} );

        //trace le graphe des vitesse du vent en rouge
        ctx0.fillStyle = ctx0.strokeStyle = "#F00";
        G.polyline(  winds );
        winds.forEach(function( p ){ G.disc(p.x, p.y,2 );} );



        //trace le graphe des vitesse du vent en rouge
        G.ctx = ctx1;
        winds.forEach(function( p,i  ){

            var o = temperatures[i];
            var w = width / data.length;
            var h = o.y - p.y;
            ctx1.fillStyle = h < 0 ? "#09C" : "#FC0";
            ctx1.fillRect( p.x, p.y, w, h );

        } );



        G.ctx = ctx2;
        ctx2.strokeStyle = "#DDD";
        graduation( p1, p2, data.length, -height );
        ctx2.strokeStyle = "#F00";
        G.polyline( temperatures );

        var t = .5 + Math.sin( Date.now() *.0005 ) * .5;
        var p = getPositionAt( temperatures, t );
        G.disc(p, 2 );




        var Kmeans = kmeans.compute( winds.concat( temperatures ), 10 );
        var centroids = Kmeans.centroids;

        G.ctx = ctx3;
        ctx3.fillStyle = ctx3.strokeStyle = "#09C";
        var points = Kmeans.points;
        points.forEach(function( p ){ G.disc(p.x, p.y,2 );G.line( p, centroids[ p.centroid ] )} );

        ctx3.fillStyle = ctx3.strokeStyle = "#F00";
        centroids.forEach(function( p ){ G.disc(p.x, p.y, p.items );} );



        var polar = [];
        G.ctx = ctx4;

        ctx4.setTransform(1,0,0,1,0, 0);
        ctx4.clearRect(0,0,ctx4.canvas.width, ctx4.canvas.height);
        var rin = 50;
        var rout = 150;

        ctx4.strokeStyle = "#DDD";
    //        ctx4.lineWidth = 2;
    //        G.circle( width/2, height/2, lerp(.5, rin, rout ) );
        ctx4.lineWidth = 1;
        G.circle( width/2, height/2, rin );
        G.circle( width/2, height/2, rout );

        ctx4.strokeStyle = "#f00";
        ctx4.beginPath();
        data.forEach( function( obj, i )
        {
            var r = map( obj.t, t_min, t_max, rin, rout );

            var a = i / data.length * PI2;
            var p = new Point( width / 2 + Math.cos( a )*r, height / 2 + Math.sin( a )*r );
            polar.push( p );
            ctx4.lineTo(p.x, p.y );

        } );
        ctx4.closePath();
        ctx4.stroke();


        ctx4.strokeStyle = "#09C";
        G.polyline( CatmullRom.compute( polar,.1, true ) );


        ctx4.strokeStyle = "#FC0";
        G.polyline( simplify.compute( quadratic.compute( polar,.1, true ), 40 ) );


    }

    var mouse = new Point();
    function onMove(e)
    {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
    }
    window.addEventListener('mousemove', onMove, false );


</script>
</body>
</html>